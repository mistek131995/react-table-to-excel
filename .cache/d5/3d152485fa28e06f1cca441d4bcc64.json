{"id":"../node_modules/@fast-csv/parse/build/src/parser/column/QuotedColumnParser.js","dependencies":[{"name":"C:\\Users\\omega\\OneDrive\\Рабочий стол\\ReactApp\\react-table-to-excel\\node_modules\\@fast-csv\\parse\\build\\src\\parser\\column\\QuotedColumnParser.js.map","includedInParent":true,"mtime":1658855089895},{"name":"C:\\Users\\omega\\OneDrive\\Рабочий стол\\ReactApp\\react-table-to-excel\\package.json","includedInParent":true,"mtime":1658855091654},{"name":"C:\\Users\\omega\\OneDrive\\Рабочий стол\\ReactApp\\react-table-to-excel\\node_modules\\@fast-csv\\parse\\package.json","includedInParent":true,"mtime":1658855089792},{"name":"./ColumnFormatter","loc":{"line":4,"column":34,"index":148},"parent":"C:\\Users\\omega\\OneDrive\\Рабочий стол\\ReactApp\\react-table-to-excel\\node_modules\\@fast-csv\\parse\\build\\src\\parser\\column\\QuotedColumnParser.js","resolved":"C:\\Users\\omega\\OneDrive\\Рабочий стол\\ReactApp\\react-table-to-excel\\node_modules\\@fast-csv\\parse\\build\\src\\parser\\column\\ColumnFormatter.js"},{"name":"../Token","loc":{"line":5,"column":24,"index":194},"parent":"C:\\Users\\omega\\OneDrive\\Рабочий стол\\ReactApp\\react-table-to-excel\\node_modules\\@fast-csv\\parse\\build\\src\\parser\\column\\QuotedColumnParser.js","resolved":"C:\\Users\\omega\\OneDrive\\Рабочий стол\\ReactApp\\react-table-to-excel\\node_modules\\@fast-csv\\parse\\build\\src\\parser\\Token.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QuotedColumnParser = void 0;\nconst ColumnFormatter_1 = require(\"./ColumnFormatter\");\nconst Token_1 = require(\"../Token\");\nclass QuotedColumnParser {\n    constructor(parserOptions) {\n        this.parserOptions = parserOptions;\n        this.columnFormatter = new ColumnFormatter_1.ColumnFormatter(parserOptions);\n    }\n    parse(scanner) {\n        if (!scanner.hasMoreCharacters) {\n            return null;\n        }\n        const originalCursor = scanner.cursor;\n        const { foundClosingQuote, col } = this.gatherDataBetweenQuotes(scanner);\n        if (!foundClosingQuote) {\n            // reset the cursor to the original\n            scanner.advanceTo(originalCursor);\n            // if we didnt find a closing quote but we potentially have more data then skip the parsing\n            // and return the original scanner.\n            if (!scanner.hasMoreData) {\n                throw new Error(`Parse Error: missing closing: '${this.parserOptions.quote || ''}' in line: at '${scanner.lineFromCursor.replace(/[\\r\\n]/g, \"\\\\n'\")}'`);\n            }\n            return null;\n        }\n        this.checkForMalformedColumn(scanner);\n        return col;\n    }\n    gatherDataBetweenQuotes(scanner) {\n        const { parserOptions } = this;\n        let foundStartingQuote = false;\n        let foundClosingQuote = false;\n        const characters = [];\n        let nextToken = scanner.nextCharacterToken;\n        for (; !foundClosingQuote && nextToken !== null; nextToken = scanner.nextCharacterToken) {\n            const isQuote = Token_1.Token.isTokenQuote(nextToken, parserOptions);\n            // ignore first quote\n            if (!foundStartingQuote && isQuote) {\n                foundStartingQuote = true;\n            }\n            else if (foundStartingQuote) {\n                if (Token_1.Token.isTokenEscapeCharacter(nextToken, parserOptions)) {\n                    // advance past the escape character so we can get the next one in line\n                    scanner.advancePastToken(nextToken);\n                    const tokenFollowingEscape = scanner.nextCharacterToken;\n                    // if the character following the escape is a quote character then just add\n                    // the quote and advance to that character\n                    if (tokenFollowingEscape !== null &&\n                        (Token_1.Token.isTokenQuote(tokenFollowingEscape, parserOptions) ||\n                            Token_1.Token.isTokenEscapeCharacter(tokenFollowingEscape, parserOptions))) {\n                        characters.push(tokenFollowingEscape.token);\n                        nextToken = tokenFollowingEscape;\n                    }\n                    else if (isQuote) {\n                        // if the escape is also a quote then we found our closing quote and finish early\n                        foundClosingQuote = true;\n                    }\n                    else {\n                        // other wise add the escape token to the characters since it wast escaping anything\n                        characters.push(nextToken.token);\n                    }\n                }\n                else if (isQuote) {\n                    // we found our closing quote!\n                    foundClosingQuote = true;\n                }\n                else {\n                    // add the token to the characters\n                    characters.push(nextToken.token);\n                }\n            }\n            scanner.advancePastToken(nextToken);\n        }\n        return { col: this.columnFormatter.format(characters.join('')), foundClosingQuote };\n    }\n    checkForMalformedColumn(scanner) {\n        const { parserOptions } = this;\n        const { nextNonSpaceToken } = scanner;\n        if (nextNonSpaceToken) {\n            const isNextTokenADelimiter = Token_1.Token.isTokenDelimiter(nextNonSpaceToken, parserOptions);\n            const isNextTokenARowDelimiter = Token_1.Token.isTokenRowDelimiter(nextNonSpaceToken);\n            if (!(isNextTokenADelimiter || isNextTokenARowDelimiter)) {\n                // if the final quote was NOT followed by a column (,) or row(\\n) delimiter then its a bad column\n                // tldr: only part of the column was quoted\n                const linePreview = scanner.lineFromCursor.substr(0, 10).replace(/[\\r\\n]/g, \"\\\\n'\");\n                throw new Error(`Parse Error: expected: '${parserOptions.escapedDelimiter}' OR new line got: '${nextNonSpaceToken.token}'. at '${linePreview}`);\n            }\n            scanner.advanceToToken(nextNonSpaceToken);\n        }\n        else if (!scanner.hasMoreData) {\n            scanner.advancePastLine();\n        }\n    }\n}\nexports.QuotedColumnParser = QuotedColumnParser;\n"},"sourceMaps":{"js":{"version":3,"file":"QuotedColumnParser.js","sourceRoot":"","sources":["../../../../src/parser/column/QuotedColumnParser.ts"],"names":[],"mappings":"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","sourcesContent":[null]}},"error":null,"hash":"b004fa78f64618336b7706158aa73768","cacheData":{"env":{}}}