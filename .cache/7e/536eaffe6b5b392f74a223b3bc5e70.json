{"id":"../node_modules/@fast-csv/format/build/src/formatter/RowFormatter.js","dependencies":[{"name":"C:\\Users\\omega\\OneDrive\\Рабочий стол\\ReactApp\\react-table-to-excel\\node_modules\\@fast-csv\\format\\build\\src\\formatter\\RowFormatter.js.map","includedInParent":true,"mtime":1658855089717},{"name":"C:\\Users\\omega\\OneDrive\\Рабочий стол\\ReactApp\\react-table-to-excel\\package.json","includedInParent":true,"mtime":1658855091654},{"name":"C:\\Users\\omega\\OneDrive\\Рабочий стол\\ReactApp\\react-table-to-excel\\node_modules\\@fast-csv\\format\\package.json","includedInParent":true,"mtime":1658855089590},{"name":"lodash.isfunction","loc":{"line":7,"column":52,"index":299},"parent":"C:\\Users\\omega\\OneDrive\\Рабочий стол\\ReactApp\\react-table-to-excel\\node_modules\\@fast-csv\\format\\build\\src\\formatter\\RowFormatter.js","resolved":"C:\\Users\\omega\\OneDrive\\Рабочий стол\\ReactApp\\react-table-to-excel\\node_modules\\lodash.isfunction\\index.js"},{"name":"lodash.isequal","loc":{"line":8,"column":49,"index":371},"parent":"C:\\Users\\omega\\OneDrive\\Рабочий стол\\ReactApp\\react-table-to-excel\\node_modules\\@fast-csv\\format\\build\\src\\formatter\\RowFormatter.js","resolved":"C:\\Users\\omega\\OneDrive\\Рабочий стол\\ReactApp\\react-table-to-excel\\node_modules\\lodash.isequal\\index.js"},{"name":"./FieldFormatter","loc":{"line":9,"column":33,"index":424},"parent":"C:\\Users\\omega\\OneDrive\\Рабочий стол\\ReactApp\\react-table-to-excel\\node_modules\\@fast-csv\\format\\build\\src\\formatter\\RowFormatter.js","resolved":"C:\\Users\\omega\\OneDrive\\Рабочий стол\\ReactApp\\react-table-to-excel\\node_modules\\@fast-csv\\format\\build\\src\\formatter\\FieldFormatter.js"},{"name":"../types","loc":{"line":10,"column":24,"index":469},"parent":"C:\\Users\\omega\\OneDrive\\Рабочий стол\\ReactApp\\react-table-to-excel\\node_modules\\@fast-csv\\format\\build\\src\\formatter\\RowFormatter.js","resolved":"C:\\Users\\omega\\OneDrive\\Рабочий стол\\ReactApp\\react-table-to-excel\\node_modules\\@fast-csv\\format\\build\\src\\types.js"}],"generated":{"js":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RowFormatter = void 0;\nconst lodash_isfunction_1 = __importDefault(require(\"lodash.isfunction\"));\nconst lodash_isequal_1 = __importDefault(require(\"lodash.isequal\"));\nconst FieldFormatter_1 = require(\"./FieldFormatter\");\nconst types_1 = require(\"../types\");\nclass RowFormatter {\n    constructor(formatterOptions) {\n        this.rowCount = 0;\n        this.formatterOptions = formatterOptions;\n        this.fieldFormatter = new FieldFormatter_1.FieldFormatter(formatterOptions);\n        this.headers = formatterOptions.headers;\n        this.shouldWriteHeaders = formatterOptions.shouldWriteHeaders;\n        this.hasWrittenHeaders = false;\n        if (this.headers !== null) {\n            this.fieldFormatter.headers = this.headers;\n        }\n        if (formatterOptions.transform) {\n            this.rowTransform = formatterOptions.transform;\n        }\n    }\n    static isRowHashArray(row) {\n        if (Array.isArray(row)) {\n            return Array.isArray(row[0]) && row[0].length === 2;\n        }\n        return false;\n    }\n    static isRowArray(row) {\n        return Array.isArray(row) && !this.isRowHashArray(row);\n    }\n    // get headers from a row item\n    static gatherHeaders(row) {\n        if (RowFormatter.isRowHashArray(row)) {\n            // lets assume a multi-dimesional array with item 0 being the header\n            return row.map((it) => it[0]);\n        }\n        if (Array.isArray(row)) {\n            return row;\n        }\n        return Object.keys(row);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    static createTransform(transformFunction) {\n        if (types_1.isSyncTransform(transformFunction)) {\n            return (row, cb) => {\n                let transformedRow = null;\n                try {\n                    transformedRow = transformFunction(row);\n                }\n                catch (e) {\n                    return cb(e);\n                }\n                return cb(null, transformedRow);\n            };\n        }\n        return (row, cb) => {\n            transformFunction(row, cb);\n        };\n    }\n    set rowTransform(transformFunction) {\n        if (!lodash_isfunction_1.default(transformFunction)) {\n            throw new TypeError('The transform should be a function');\n        }\n        this._rowTransform = RowFormatter.createTransform(transformFunction);\n    }\n    format(row, cb) {\n        this.callTransformer(row, (err, transformedRow) => {\n            if (err) {\n                return cb(err);\n            }\n            if (!row) {\n                return cb(null);\n            }\n            const rows = [];\n            if (transformedRow) {\n                const { shouldFormatColumns, headers } = this.checkHeaders(transformedRow);\n                if (this.shouldWriteHeaders && headers && !this.hasWrittenHeaders) {\n                    rows.push(this.formatColumns(headers, true));\n                    this.hasWrittenHeaders = true;\n                }\n                if (shouldFormatColumns) {\n                    const columns = this.gatherColumns(transformedRow);\n                    rows.push(this.formatColumns(columns, false));\n                }\n            }\n            return cb(null, rows);\n        });\n    }\n    finish(cb) {\n        const rows = [];\n        // check if we should write headers and we didnt get any rows\n        if (this.formatterOptions.alwaysWriteHeaders && this.rowCount === 0) {\n            if (!this.headers) {\n                return cb(new Error('`alwaysWriteHeaders` option is set to true but `headers` option not provided.'));\n            }\n            rows.push(this.formatColumns(this.headers, true));\n        }\n        if (this.formatterOptions.includeEndRowDelimiter) {\n            rows.push(this.formatterOptions.rowDelimiter);\n        }\n        return cb(null, rows);\n    }\n    // check if we need to write header return true if we should also write a row\n    // could be false if headers is true and the header row(first item) is passed in\n    checkHeaders(row) {\n        if (this.headers) {\n            // either the headers were provided by the user or we have already gathered them.\n            return { shouldFormatColumns: true, headers: this.headers };\n        }\n        const headers = RowFormatter.gatherHeaders(row);\n        this.headers = headers;\n        this.fieldFormatter.headers = headers;\n        if (!this.shouldWriteHeaders) {\n            // if we are not supposed to write the headers then\n            // always format the columns\n            return { shouldFormatColumns: true, headers: null };\n        }\n        // if the row is equal to headers dont format\n        return { shouldFormatColumns: !lodash_isequal_1.default(headers, row), headers };\n    }\n    // todo change this method to unknown[]\n    gatherColumns(row) {\n        if (this.headers === null) {\n            throw new Error('Headers is currently null');\n        }\n        if (!Array.isArray(row)) {\n            return this.headers.map((header) => row[header]);\n        }\n        if (RowFormatter.isRowHashArray(row)) {\n            return this.headers.map((header, i) => {\n                const col = row[i];\n                if (col) {\n                    return col[1];\n                }\n                return '';\n            });\n        }\n        // if its a one dimensional array and headers were not provided\n        // then just return the row\n        if (RowFormatter.isRowArray(row) && !this.shouldWriteHeaders) {\n            return row;\n        }\n        return this.headers.map((header, i) => row[i]);\n    }\n    callTransformer(row, cb) {\n        if (!this._rowTransform) {\n            return cb(null, row);\n        }\n        return this._rowTransform(row, cb);\n    }\n    formatColumns(columns, isHeadersRow) {\n        const formattedCols = columns\n            .map((field, i) => this.fieldFormatter.format(field, i, isHeadersRow))\n            .join(this.formatterOptions.delimiter);\n        const { rowCount } = this;\n        this.rowCount += 1;\n        if (rowCount) {\n            return [this.formatterOptions.rowDelimiter, formattedCols].join('');\n        }\n        return formattedCols;\n    }\n}\nexports.RowFormatter = RowFormatter;\n"},"sourceMaps":{"js":{"version":3,"file":"RowFormatter.js","sourceRoot":"","sources":["../../../src/formatter/RowFormatter.ts"],"names":[],"mappings":"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","sourcesContent":[null]}},"error":null,"hash":"92ec5d4ff612aad77b142ef152cc34e2","cacheData":{"env":{}}}